<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: node_modules/ws/lib/Sender.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: node_modules/ws/lib/Sender.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*!
 * ws: a node.js websocket client
 * Copyright(c) 2011 Einar Otto Stangvik &lt;einaros@gmail.com>
 * MIT Licensed
 */

var events = require('events')
  , util = require('util')
  , EventEmitter = events.EventEmitter
  , ErrorCodes = require('./ErrorCodes')
  , bufferUtil = require('./BufferUtil').BufferUtil;

/**
 * HyBi Sender implementation
 */

function Sender(socket) {
  this._socket = socket;
  this.firstFragment = true;
}

/**
 * Inherits from EventEmitter.
 */

util.inherits(Sender, events.EventEmitter);

/**
 * Sends a close instruction to the remote party.
 *
 * @api public
 */

Sender.prototype.close = function(code, data, mask) {
  if (typeof code !== 'undefined') {
    if (typeof code !== 'number' ||
      !ErrorCodes.isValidErrorCode(code)) throw new Error('first argument must be a valid error code number');
  }
  code = code || 1000;
  var dataBuffer = new Buffer(2 + (data ? Buffer.byteLength(data) : 0));
  writeUInt16BE.call(dataBuffer, code, 0);
  if (dataBuffer.length > 2) dataBuffer.write(data, 2);
  this.frameAndSend(0x8, dataBuffer, true, mask);
};

/**
 * Sends a ping message to the remote party.
 *
 * @api public
 */

Sender.prototype.ping = function(data, options) {
  var mask = options &amp;&amp; options.mask;
  this.frameAndSend(0x9, data || '', true, mask);
};

/**
 * Sends a pong message to the remote party.
 *
 * @api public
 */

Sender.prototype.pong = function(data, options) {
  var mask = options &amp;&amp; options.mask;
  this.frameAndSend(0xa, data || '', true, mask);
};

/**
 * Sends text or binary data to the remote party.
 *
 * @api public
 */

Sender.prototype.send = function(data, options, cb) {
  var finalFragment = options &amp;&amp; options.fin === false ? false : true;
  var mask = options &amp;&amp; options.mask;
  var opcode = options &amp;&amp; options.binary ? 2 : 1;
  if (this.firstFragment === false) opcode = 0;
  else this.firstFragment = false;
  if (finalFragment) this.firstFragment = true
  this.frameAndSend(opcode, data, finalFragment, mask, cb);
};

/**
 * Frames and sends a piece of data according to the HyBi WebSocket protocol.
 *
 * @api private
 */

Sender.prototype.frameAndSend = function(opcode, data, finalFragment, maskData, cb) {
  var canModifyData = false;

  if (!data) {
    try {
      this._socket.write(new Buffer([opcode | (finalFragment ? 0x80 : 0), 0 | (maskData ? 0x80 : 0)].concat(maskData ? [0, 0, 0, 0] : [])), 'binary', cb);
    }
    catch (e) {
      if (typeof cb == 'function') cb(e);
      else this.emit('error', e);
    }
    return;
  }

  if (!Buffer.isBuffer(data)) {
    canModifyData = true;
    if (data &amp;&amp; (typeof data.byteLength !== 'undefined' || typeof data.buffer !== 'undefined')) {
      data = getArrayBuffer(data);
    } else {
      data = new Buffer(data);
    }
  }

  var dataLength = data.length
    , dataOffset = maskData ? 6 : 2
    , secondByte = dataLength;

  if (dataLength >= 65536) {
    dataOffset += 8;
    secondByte = 127;
  }
  else if (dataLength > 125) {
    dataOffset += 2;
    secondByte = 126;
  }

  var mergeBuffers = dataLength &lt; 32768 || (maskData &amp;&amp; !canModifyData);
  var totalLength = mergeBuffers ? dataLength + dataOffset : dataOffset;
  var outputBuffer = new Buffer(totalLength);
  outputBuffer[0] = finalFragment ? opcode | 0x80 : opcode;

  switch (secondByte) {
    case 126:
      writeUInt16BE.call(outputBuffer, dataLength, 2);
      break;
    case 127:
      writeUInt32BE.call(outputBuffer, 0, 2);
      writeUInt32BE.call(outputBuffer, dataLength, 6);
  }

  if (maskData) {
    outputBuffer[1] = secondByte | 0x80;
    var mask = this._randomMask || (this._randomMask = getRandomMask());
    outputBuffer[dataOffset - 4] = mask[0];
    outputBuffer[dataOffset - 3] = mask[1];
    outputBuffer[dataOffset - 2] = mask[2];
    outputBuffer[dataOffset - 1] = mask[3];
    if (mergeBuffers) {
      bufferUtil.mask(data, mask, outputBuffer, dataOffset, dataLength);
      try {
        this._socket.write(outputBuffer, 'binary', cb);
      }
      catch (e) {
        if (typeof cb == 'function') cb(e);
        else this.emit('error', e);
      }
    }
    else {
      bufferUtil.mask(data, mask, data, 0, dataLength);
      try {
        this._socket.write(outputBuffer, 'binary');
        this._socket.write(data, 'binary', cb);
      }
      catch (e) {
        if (typeof cb == 'function') cb(e);
        else this.emit('error', e);
      }
    }
  }
  else {
    outputBuffer[1] = secondByte;
    if (mergeBuffers) {
      data.copy(outputBuffer, dataOffset);
      try {
        this._socket.write(outputBuffer, 'binary', cb);
      }
      catch (e) {
        if (typeof cb == 'function') cb(e);
        else this.emit('error', e);
      }
    }
    else {
      try {
        this._socket.write(outputBuffer, 'binary');
        this._socket.write(data, 'binary', cb);
      }
      catch (e) {
        if (typeof cb == 'function') cb(e);
        else this.emit('error', e);
      }
    }
  }
};

module.exports = Sender;

function writeUInt16BE(value, offset) {
  this[offset] = (value &amp; 0xff00)>>8;
  this[offset+1] = value &amp; 0xff;
}

function writeUInt32BE(value, offset) {
  this[offset] = (value &amp; 0xff000000)>>24;
  this[offset+1] = (value &amp; 0xff0000)>>16;
  this[offset+2] = (value &amp; 0xff00)>>8;
  this[offset+3] = value &amp; 0xff;
}

function getArrayBuffer(data) {
  // data is either an ArrayBuffer or ArrayBufferView.
  var array = new Uint8Array(data.buffer || data)
    , l = data.byteLength || data.length
    , o = data.byteOffset || 0
    , buffer = new Buffer(l);
  for (var i = 0; i &lt; l; ++i) {
    buffer[i] = array[o+i];
  }
  return buffer;
}

function getRandomMask() {
  return new Buffer([
    ~~(Math.random() * 255),
    ~~(Math.random() * 255),
    ~~(Math.random() * 255),
    ~~(Math.random() * 255)
  ]);
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CommanderError.html">CommanderError</a></li></ul><h3>Global</h3><ul><li><a href="global.html"></a></li><li><a href="global.html#bufferIndex">bufferIndex</a></li><li><a href="global.html#camelcase">camelcase</a></li><li><a href="global.html#CloseEvent">CloseEvent</a></li><li><a href="global.html#Command">Command</a></li><li><a href="global.html#creatingNewHabit">creatingNewHabit</a></li><li><a href="global.html#EMPTY">EMPTY</a></li><li><a href="global.html#EventEmitter">EventEmitter</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#global">global</a></li><li><a href="global.html#global#handleHybiUpgrade">handleHybiUpgrade</a></li><li><a href="global.html#global#humanReadableArgName">humanReadableArgName</a></li><li><a href="global.html#global#incrementNodeInspectorPort">incrementNodeInspectorPort</a></li><li><a href="global.html#global#initAsServerClient">initAsServerClient</a></li><li><a href="global.html#global#MessageEvent">MessageEvent</a></li><li><a href="global.html#global#opcodes">opcodes</a></li><li><a href="global.html#global#OpenEvent">OpenEvent</a></li><li><a href="global.html#global#Option">Option</a></li><li><a href="global.html#global#optionalWrap">optionalWrap</a></li><li><a href="global.html#global#outputHelpIfNecessary">outputHelpIfNecessary</a></li><li><a href="global.html#global#outputHelpIfRequested">outputHelpIfRequested</a></li><li><a href="global.html#global#pad">pad</a></li><li><a href="global.html#global#protocolVersion">protocolVersion</a></li><li><a href="global.html#global#readUInt16BE">readUInt16BE</a></li><li><a href="global.html#global#Receiver">Receiver</a></li><li><a href="global.html#global#Sender">Sender</a></li><li><a href="global.html#global#set">set</a></li><li><a href="global.html#global#WebSocket">WebSocket</a></li><li><a href="global.html#global#WebSocketServer">WebSocketServer</a></li><li><a href="global.html#global#wrap">wrap</a></li><li><a href="global.html#global#ws">ws</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Feb 23 2020 00:42:27 GMT-0800 (Pacific Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
